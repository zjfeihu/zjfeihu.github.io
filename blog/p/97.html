<!doctype html>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>WEB++开发之网格位置算法</title>
<link href=../style/main.css rel=stylesheet>
<script src=../style/main.js></script>
<body>
<div id=detail>
    <h1>WEB++开发之网格位置算法</h1>
    <div class=content><h2>前言</h2><p>WEB++桌面系统中，有很多地方用到了网格位置算法，比如桌面图标的拖放操作，即把一个容器分成若干大小相等的网格，然后获取一个坐标在网格中的位置。</p><h2>算法演示</h2><p><style> #gridbox{position:relative;width:300px;height:300px;background:#666;overflow:hidden;} #gridbox span{float:left;border:1px solid #fff;border-width:0 1px 1px 0;color:#eee}</style></p><script src=../style/z.js></script><button onclick=changegrid()>改变网格</button><p>点击黑色网格显示当前位置，位置从0开始，纵向递增</p><div id=gridbox></div><script>
var gridbox = Z('#gridbox');
var width = gridbox.width();
var height = gridbox.height();

var gridsize;

changegrid();

gridbox.click(function(e){

    var index = getGridindex(gridbox, gridsize, [e.clientX, e.clientY + Z.scrollTop()]);
    if(index > -1 && Z(e.target).tag('SPAN')){
        Z(e.target).html(index);
    }

})

function changegrid(){

    gridsize = [20 + Math.random() * 20 | 0, 20 + Math.random() * 20 | 0];

    var num = Math.random();

    if(num < 0.3){
        gridsize[0] = 0;
    }else if(num > 0.7){
        gridsize[1] = 0;
    }

    var gridwidth = gridsize[0] || width;
    var gridheight = gridsize[1] || height;
    var gridcount;

    if(!gridsize[0] || !gridsize[1]){
        gridcount = (gridsize[0] ? width/gridsize[0] : height/gridsize[1])|0;
    }else{
        gridcount = (width/gridsize[0]|0) * (height/gridsize[1]|0);
    }

    Z('#gridbox').html(
        Array( gridcount + 1)
        .join('<span style="width:'+ (gridwidth - 1) +'px; height:'+ (gridheight - 1) +'px"></span>'))

}

function getGridindex(box, gridsize, point){

    var gridwidth = gridsize[0];
    var gridheight = gridsize[1];
    var x = point[0];
    var y = point[1];
    var left, top, width, height;
    var rows, cols; //网格行列

    if(
        x < (left = box.offsetLeft()) || 
        x > left + (width = box.offsetWidth()) ||
        y < (top = box.offsetTop()) ||
        y > top + (height = box.offsetHeight())
    ){
        return -1;
    }

    var rx, ry;

    if(gridwidth){
        cols = Math.max(1, (width/gridwidth)|0);
        rx = Math.floor( (x - left) / gridwidth );
        rx = Math.min(cols, rx);
    }

    if(gridheight){
        rows = Math.max(1, (height/gridheight)|0)
        ry = Math.floor( (y - top) / gridheight );
        ry = Math.min(rows, ry);
    }

    if( (+!!gridwidth) ^ (+!!gridheight) ){ //只存在一个值
        return (rx || ry)|0;
    }

    return rows * rx  + ry; //2个值都存在，则纵向读取生成位置

}

</script><h2>网格位置算法</h2><textarea class="code-js" edit=off >

//getGridindex(box, [30, 0], [100, 100]) 当gridsize有一个值为零，那么计算单行或者单列网格

function getGridindex(box, gridsize, point){ //box为容器，gridsize为网格大小，point为坐标位置

    var gridwidth = gridsize[0];
    var gridheight = gridsize[1];
    var x = point[0];
    var y = point[1];
    var left, top, width, height;
    var rows, cols; //网格行列

    if(
        x < (left = box.offsetLeft()) || 
        x > left + (width = box.offsetWidth()) ||
        y < (top = box.offsetTop()) ||
        y > top + (height = box.offsetHeight())
    ){
        return -1;
    }

    var rx, ry; //二维坐标

    if(gridwidth){ //列坐标
        cols = Math.max(1, (width/gridwidth)|0);
        rx = Math.floor( (x - left) / gridwidth );
        rx = Math.min(cols, rx);
    }

    if(gridheight){ //行坐标
        rows = Math.max(1, (height/gridheight)|0)
        ry = Math.floor( (y - top) / gridheight );
        ry = Math.min(rows, ry);
    }

    if( (+!!gridwidth) ^ (+!!gridheight) ){ //只存在一个值
        return (rx || ry)|0;
    }

    return rows * rx  + ry; //2个值都存在，则纵向读取生成位置

}

</textarea></div>
</div>
